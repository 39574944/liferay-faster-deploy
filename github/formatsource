#!/bin/bash

antformatsource() {
	if [ -d "$GIT_ROOT/modules" ]; then
		if [ ! -d "$GIT_ROOT/tools/sdk" ]; then
			pushd "$GIT_ROOT" > /dev/null
			ant setup-sdk
			popd > /dev/null
		fi

		if [ ! -d tools/sdk/dependencies/com.liferay.source.formatter/lib ]; then
			. $(dirname "${BASH_SOURCE[0]}")/../gitcd/gitcdb com.liferay.source.formatter
			$(dirname "${BASH_SOURCE[0]}")/../gw deploy
			cd -
		fi
	fi

	ARGS=

	if [ "" != "$1" ] && [ -f $1 ]; then
		ARGS="-Dsource.files=$PWD/$1"
	elif [ "" != "$1" ]; then
		check $@

		if [[ 0 -ne $? ]]; then
			return 1
		fi

		ARGS="-Dformat.current.branch=true -Dgit.working.branch.name=$1"
	else
		ARGS="-Dformat.local.changes=true"
	fi

	cd $GIT_ROOT/portal-impl
	pwd

	echo ant format-source $ARGS
	ant format-source $ARGS
}

check() {
	BASE_COMMIT=$(git log -1 --pretty='%H' $1)

	if [ "" == "$BASE_COMMIT" ]; then
		echo "$1 is not a known branch, tag, or revision"
		return 1
	fi

	git merge-base --is-ancestor $BASE_COMMIT HEAD

	if [[ 0 -ne $? ]]; then
		echo "You must rebase against $1 if you want to use it for source formatting"
		return 1
	fi

	MAX_COMMITS=$2

	if [ "" == "$MAX_COMMITS" ]; then
		MAX_COMMITS=10
	fi

	ACTUAL_COMMITS=$(git log $1..HEAD | wc -l)

	if [[ $MAX_COMMITS -lt $ACTUAL_COMMITS ]]; then
		echo "There have been ${ACTUAL_COMMITS} commits on this branch compared to ${1}."
		echo "If you're sure that $1 has been rebased against upstream,"
		echo "please specify the above number as a second parameter."
		return 1
	fi
}

formatbranch() {
	# Identify the base branch

	. $(dirname "${BASH_SOURCE[0]}")/../getparent

	if [ "" == "$BASE_BRANCH" ]; then
		echo Unable to identify base branch
		return 1
	fi

	# Find the closest ancestor based on which one has the fewest commits

	local origin_remote=$(git for-each-ref --format='%(refname)' refs/remotes/ | grep "/origin[^/]*/${BASE_BRANCH}$" | cut -d'/' -f 3)
	local upstream_remote=$(git for-each-ref --format='%(refname)' refs/remotes/ | grep "/upstream[^/]*/${BASE_BRANCH}$" | cut -d'/' -f 3)
	local base_remote=

	if [[ $(git log --pretty='%H' ${origin_remote}/${BASE_BRANCH}..HEAD | wc -l) -gt $(git log --pretty='%H' ${upstream_remote}/${BASE_BRANCH}..HEAD | wc -l) ]]; then
		base_remote=$upstream_remote
	else
		base_remote=$origin_remote
	fi

	# Compute the changes

	$(dirname "${BASH_SOURCE[0]}")/../gitchanges ${base_remote}/${BASE_BRANCH}

	# Scan the Gradle changes to build one large command

	cat /dev/null > $GIT_ROOT/.redeploy/format.txt

	for folder in $(cat "$GIT_ROOT/.redeploy/changes_gradle_1.txt" "$GIT_ROOT/.redeploy/changes_gradle_2.txt"); do
		if [ "" != "$(grep -F "$folder" $GIT_ROOT/.redeploy/changes.txt | grep -F 'src')" ]; then
			echo $folder | cut -d'/' -f 2- | tr '/' ':' | awk '{ print ":" $1 ":formatSource" }' >> $GIT_ROOT/.redeploy/format.txt
		fi
	done

	if [[ 0 -ne $(wc -l $GIT_ROOT/.redeploy/format.txt | cut -d' ' -f 1) ]]; then
		cd modules

		cat $GIT_ROOT/.redeploy/format.txt | xargs $(dirname "${BASH_SOURCE[0]}")/../gw
		EXIT_CODE=$?

		cd -

		if [[ 0 -ne $EXIT_CODE ]]; then
			return $EXIT_CODE
		fi
	fi

	if [[ 0 -ne $(wc -l "$GIT_ROOT/.redeploy/changes_ant.txt" | cut -d' ' -f 1) ]]; then
		antformatsource ${upstream_remote}/$BASE_BRANCH $(git log ${upstream_remote}/$BASE_BRANCH..HEAD | wc -l)

		EXIT_CODE=$?

		if [[ 0 -ne $EXIT_CODE ]]; then
			return $EXIT_CODE
		fi
	fi
}

gradleformatsource() {
	ARGS=

	if [ "" != "$1" ] && [ -f $1 ]; then
		ARGS="-DformatSource.source.files=$PWD/$1"
	elif [ "local" == "$1" ]; then
		ARGS="-DformatSource.format.local.changes=true"
	fi

	echo gradlew formatSource $ARGS
	$(dirname "${BASH_SOURCE[0]}")/../gw formatSource $ARGS
}

setopts() {
	. $(dirname "${BASH_SOURCE[0]}")/../setopts
}

setopts

if [[ 0 -ne $? ]]; then
	exit 1
fi

if [ "" == "$1" ]; then
	formatbranch
elif [ -f build.gradle ]; then
	gradleformatsource $@
else
	antformatsource $@
fi