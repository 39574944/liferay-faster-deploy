#!/bin/bash

applychanges() {
	local COMPARE_HASH=

	if [ -f .redeploy/last_deploy.txt ]; then
		COMPARE_HASH=$(cat .redeploy/last_deploy.txt)

		if [ "" != "$COMPARE_HASH" ]; then
			git merge-base --is-ancestor $COMPARE_HASH $CURRENT_HASH

			if [[ 0 -ne $? ]]; then
				COMPARE_HASH=
			fi
		fi
	fi

	if [ "" == "$COMPARE_HASH" ]; then
		COMPARE_HASH=$NEW_BASELINE
	fi

	gitchanges $COMPARE_HASH

	# If any of the folders that are affected is one that has
	# one of the version range macros, make sure to fix it

	for folder in $(git ls-files modules | grep build.gradle | xargs grep -l 'version: "\[' | dirnames); do
		if [ "" != "$(grep -F "$folder" .redeploy/changes_gradle_2.txt)" ]; then
			$(dirname "${BASH_SOURCE[0]}")/fixbnd $folder
		fi
	done

	echo ""
	echo "Deploying folders:"
	cat .redeploy/changes_ant.txt | awk '{ print " * " $1 }'

	echo ""
	echo "Deploying modules:"
	cat .redeploy/changes_gradle_1.txt .redeploy/changes_gradle_2.txt | awk '{ print " * " $1 }'
	echo ""

	# Check if we need to rerun cachenpm

	if isneedscachenpm; then
		$(dirname "${BASH_SOURCE[0]}")/cachenpm
	fi

	# First, check to see if there are any modules we need to deploy early

	if [[ 0 -ne $(wc -l .redeploy/changes_gradle_1.txt | cut -d' ' -f 1) ]]; then
		deployportalpre

		if [[ 0 -ne $? ]]; then
			return 1
		fi
	fi

	# Next, check to see if there is anything we need to deploy with ant

	if [[ 0 -ne $(wc -l .redeploy/changes_ant.txt | cut -d' ' -f 1) ]]; then
		deployant

		if [[ 0 -ne $? ]]; then
			return 1
		fi
	fi

	# Finally, check to see if there is anything we need to deploy with gradle

	if [[ 0 -ne $(wc -l .redeploy/changes_gradle_2.txt | cut -d' ' -f 1) ]]; then
		deploymodules

		if [[ 0 -ne $? ]]; then
			return 1
		fi
	fi

	echo -n $CURRENT_HASH > .redeploy/last_deploy.txt

	if [ -f .redeploy/changes_ant.txt ] && [ "" != "$(grep util .redeploy/changes_ant.txt)" ]; then
		echo "Modified util-*.jar, must clear the osgi/state folder for WABs to be rebuilt"
	fi
}

cdroot() {
	if [ ! -f "$GIT_ROOT/release.properties" ]; then
		echo "Unable to find release.properties at version control root"
		return 1
	fi

	builtin cd $GIT_ROOT
}

deployant() {
	# Make sure that we have registry-api and anything else that is
	# part of the portal-pre profile

	if [ ! -d tmp/lib-pre ]; then
		deployportalpre
	fi

	if [ "" != "$(grep setup-libs build.xml)" ] && [ ! -f .redeploy/setup_libs.txt ]; then
		ant setup-libs
		touch .redeploy/setup_libs.txt
	fi

	# Some of the builds (notably util-taglib) need the rest of the
	# portal to have been built, so we can copy that from our bundle

	for folder in $(ls -1); do
		if [ -d $folder/src ] && [ ! -f $folder/$folder.jar ]; then
			if [ -f $TARGET_FOLDER/tomcat-*/webapps/ROOT/WEB-INF/lib/$folder.jar ]; then
				cp $TARGET_FOLDER/tomcat-*/webapps/ROOT/WEB-INF/lib/$folder.jar $folder
			elif [ -f $TARGET_FOLDER/tomcat-*/lib/ext/$folder.jar ]; then
				cp $TARGET_FOLDER/tomcat-*/lib/ext/$folder.jar $folder
			fi

			if [ -f $folder/$folder.jar ]; then
				mkdir -p $folder/classes
				unzip -qq $folder/$folder.jar -d $folder/classes
			fi
		fi
	done

	# Finally, iterate over the folders that are listed for deployment

	for folder in $(cat .redeploy/changes_ant.txt); do
		echo -e "\nBuilding $folder"

		pushd $folder > /dev/null

		if [ -f bnd.bnd ]; then
			ant deploy install-portal-snapshot
		else
			ant deploy
		fi

		EXIT_STATUS=$?

		popd > /dev/null

		if [[ 0 -ne $EXIT_STATUS ]]; then
			return $EXIT_STATUS
		fi
	done
}

deploymodules() {
	cd modules
	cat ../.redeploy/changes_gradle_2.txt | cut -d'/' -f 2- | tr '/' ':' | awk '{ print ":" $1 ":deploy" }' | xargs $(dirname "${BASH_SOURCE[0]}")/gw
	cd ..
}

deployportalpre() {
	cd modules
	gw -Dbuild.profile=portal-pre -Pforced.deploy.dir=${PWD}/../tmp/lib-pre deploy
	cd ..
}

dirnames() {
	python $(dirname "${BASH_SOURCE[0]}")/dirnames.py
}

downloadbranch() {
	# Make sure there is a build on the archive mirror for our branch

	SHORT_NAME=$(echo $BASE_BRANCH | sed 's/ee-//g' | sed 's/\.//g')
	BUILD_NAME=$(getbuildname)

	if [ "" == "$BUILD_NAME" ]; then
		BUILD_NAME=$(basename $(find "$HOME/.liferay/builds" -name ${SHORT_NAME}*.tar.gz | sort | tail -1))

		if [ "" == "$BUILD_NAME" ]; then
			echo "Could not find build for $BASE_BRANCH"
			return 1
		fi

		NEW_BASELINE=$(cat "$HOME/.liferay/builds/${BUILD_NAME}.githash")
		echo "Could not find build for $BASE_BRANCH, using ${BUILD_NAME}"
		return 0
	fi

	# Acquire the hash and make sure we have it

	NEW_BASELINE=$(getbuildhash)

	if [ "" == "$(git log -1 $NEW_BASELINE 2> /dev/null)" ]; then
		echo "Checking remotes for updates"

		for remote in $(git remote); do
			git fetch $remote --no-tags
		done
	fi

	# Rebase against the acquired hash if necessary

	if [ "$CURRENT_BRANCH" != "$BASE_BRANCH" ]; then
		BASE_HASH=$(git log -1 --pretty='%H' $BASE_BRANCH)

		if [ "$BASE_HASH" != "$NEW_BASELINE" ]; then
			NEEDS_STASH=$(git status -s | grep -v '??')

			if [ "" != "$NEEDS_STASH" ]; then
				git stash
			fi

			git checkout -f $BASE_BRANCH && git rebase $NEW_BASELINE && git reset --hard $NEW_BASELINE && git checkout $CURRENT_BRANCH

			REBASE_STATUS=$?

			if [ "" != "$NEEDS_STASH" ]; then
				git stash pop
			fi

			if [[ 0 -ne $REBASE_STATUS ]]; then
				echo "Failed to update base branch"
				return $REBASE_STATUS
			fi
		fi
	fi

	# Download the build if we haven't done so already, making
	# sure to clean up past builds to not take up too much space

	if [ ! -f "$HOME/.liferay/builds/$BUILD_NAME" ]; then
		find "$HOME/.liferay/builds/" -name "${SHORT_NAME}*.tar.gz" | xargs rm

		echo "Downloading snapshot for $SHORT_NAME ($NEW_BASELINE)"
		getbuild "${BRANCH_ARCHIVE_MIRROR}/${BUILD_NAME}"
	fi
}

downloadbuild() {
	# Identify the folder we build into

	CURRENT_BRANCH=$(git symbolic-ref --short HEAD)

	if [ "" == "$CURRENT_BRANCH" ]; then
		echo "Unable to build from detached head"
		return 1
	fi

	if [ "" != "$BUILD_FOLDER_SUFFIX" ]; then
		TARGET_FOLDER=${BUILD_FOLDER_PREFIX}/${CURRENT_BRANCH}/${BUILD_FOLDER_SUFFIX}
	else
		TARGET_FOLDER=${BUILD_FOLDER_PREFIX}/${CURRENT_BRANCH}
	fi

	# Update app.server.$USER.properties

	TARGET_FOLDER="$TARGET_FOLDER" \
		$(dirname "${BASH_SOURCE[0]}")/appserverprops

	# Identify the base branch so we know what to fetch

	. $(dirname "${BASH_SOURCE[0]}")/getparent

	# If Tomcat is already running, we shouldn't proceed
	# any further than identifying commit information.

	if [ "" != "$(jps | grep Bootstrap)" ] && [ -f "$TARGET_FOLDER/baseline.txt" ]; then
		echo "Tomcat is already running, skipping bundle update"
		NEW_BASELINE=$(cat "$TARGET_FOLDER/baseline.txt")
		return 0
	fi

	# If we're using a tag, shortcut

	MAX_COMMITS=$1

	if [ "" == "$MAX_COMMITS" ]; then
		MAX_COMMITS=10
	fi

	if [[ 0 -ne $MAX_COMMITS ]] && [ "" != "$BASE_TAG" ]; then
		ACTUAL_COMMITS=$(git log ${BASE_TAG}..HEAD | wc -l)

		if [[ $MAX_COMMITS -lt $ACTUAL_COMMITS ]]; then
			echo "There have been ${ACTUAL_COMMITS} commits on this branch compared to ${BASE_TAG}."
			echo "If this is based on ${BASE_BRANCH}, please specify 0 as a parameter."
			echo "If this is based on ${BASE_TAG}, please specify $ACTUAL_COMMITS as a parameter."
			return 1
		fi

		downloadtag && extract
		return $?
	fi

	# If we have a known branch, we'll use it

	downloadbranch && rebasebranch && extract
	return $?
}

downloadtag() {
	NEW_BASELINE=$BASE_TAG
	BUILD_NAME=${BASE_TAG}.tar.gz

	if [ ! -f "$HOME/.liferay/builds/$BUILD_NAME" ]; then
		echo "Downloading snapshot for $BASE_TAG"
		getbuild "${TAG_ARCHIVE_MIRROR}/${BUILD_NAME}"
	fi

	if [ ! -f "$HOME/.liferay/builds/$BUILD_NAME" ]; then
		echo "No build release archive available for $BASE_TAG"
		return 1
	fi
}

extract() {
	# Figure out if we need to untar the build, based on whether the
	# baseline hash has changed

	mkdir -p "$TARGET_FOLDER"

	OLD_BASELINE=

	if [ -f "$TARGET_FOLDER/baseline.txt" ]; then
		OLD_BASELINE=$(cat "$TARGET_FOLDER/baseline.txt")
	fi

	# Cleanup the folders before we untar. Only file we exclude is
	# the Hypersonic data files if we already have them.

	if [ "$OLD_BASELINE" == "$NEW_BASELINE" ]; then
		echo "$TARGET_FOLDER is already up to date"
		return 0
	fi

	rm -f .redeploy/last_deploy.txt

	pushd "$TARGET_FOLDER" > /dev/null

	rm -rf tomcat* osgi tools work

	EXCLUDES=

	if [ -d data ]; then
		EXCLUDES="--exclude='data/hypersonic/lportal.script' --exclude='data/hypersonic/lportal.properties'"
	fi

	tar -zxf "$HOME/.liferay/builds/${BUILD_NAME}" $EXCLUDES

	echo -n "$NEW_BASELINE" > "baseline.txt"

	popd > /dev/null
}

getbuild() {
	builtin cd "$HOME/.liferay/builds/"

	if [[ "$1" == s3://* ]]; then
		aws s3 cp "$1" .
	else
		wget "$1"
	fi

	builtin cd -
}

getbuildhash() {
	if [ -f "$HOME/.liferay/builds/${BUILD_NAME}.githash" ]; then
		cat "$HOME/.liferay/builds/${BUILD_NAME}.githash"
		return 0
	fi

	BUILD_LOG=$(echo $BUILD_NAME | cut -d'.' -f 1).log
	UPDATE_TIME=$(echo $BUILD_NAME | cut -d'.' -f 1 | cut -d'-' -f 2)

	if [[ "$BRANCH_ARCHIVE_MIRROR" == s3://* ]]; then
		local BUCKET_NAME=$(echo $BRANCH_ARCHIVE_MIRROR | cut -d '/' -f 3)
		local KEY_NAME=$(echo $BRANCH_ARCHIVE_MIRROR | cut -d '/' -f 4-)

		aws s3api get-object --bucket $BUCKET_NAME --key $KEY_NAME/${BUILD_LOG} --range bytes=0-49 githash.txt > /dev/null
		tail -1 githash.txt | tee "$HOME/.liferay/builds/${BUILD_NAME}.githash"
		rm githash.txt
	else
		curl -r 0-49 -s ${BRANCH_ARCHIVE_MIRROR}/${BUILD_LOG} | tail -1 | tee "$HOME/.liferay/builds/${BUILD_NAME}.githash"
	fi

	exit 0
}

getbuildname() {
	if [[ "$BRANCH_ARCHIVE_MIRROR" == s3://* ]]; then
		aws s3 ls $BRANCH_ARCHIVE_MIRROR/ | awk '{ print $4 }' | grep ${SHORT_NAME}'-[^"]*.tar.gz$' | sort | tail -1
	else
		curl -s --connect-timeout 2 $BRANCH_ARCHIVE_MIRROR/ | grep -o '<a href="'${SHORT_NAME}'-[^"]*.tar.gz">' | cut -d'"' -f 2 | sort | tail -1
	fi
}

gitchanges() {
	. $(dirname "${BASH_SOURCE[0]}")/gitchanges $@
}

gw() {
	$(dirname "${BASH_SOURCE[0]}")/gw $@
}

isneedscachenpm() {
	for folder in $(cat .redeploy/changes_gradle_2.txt); do
		if [ -f "$folder/package.json" ]; then
			return 0
		fi
	done

	return 1
}

rebasebranch() {
	git merge-base --is-ancestor $NEW_BASELINE $CURRENT_HASH

	if [[ 0 -eq $? ]]; then
		echo "$CURRENT_BRANCH is already rebased against $SHORT_NAME ($NEW_BASELINE)"
		return 0
	fi

	echo "Rebasing against $SHORT_NAME ($NEW_BASELINE)"
	git rebase $NEW_BASELINE
	return $?
}

redeploy() {
	downloadbuild $1 && applychanges
}

setopts() {
	. $(dirname "${BASH_SOURCE[0]}")/setopts
}

if [ -z "${BUILD_FOLDER_PREFIX}" ]; then
	echo "Please set a BUILD_FOLDER_PREFIX for the build"
	exit 1
fi

echo "Using $BUILD_FOLDER_PREFIX as the root folder"

mkdir -p "$BUILD_FOLDER_PREFIX/.test"

if [ ! -d "$BUILD_FOLDER_PREFIX/.test" ]; then
	echo "${USER} does not have permission to create folders in ${BUILD_FOLDER_PREFIX}"
	exit 1
fi

rmdir "$BUILD_FOLDER_PREFIX/.test"

if [ -z "${TAG_ARCHIVE_MIRROR}" ]; then
	echo "Please set a TAG_ARCHIVE_MIRROR for the build"
	exit 1
fi

if [ -z "${BRANCH_ARCHIVE_MIRROR}" ]; then
	echo "Please set a BRANCH_ARCHIVE_MIRROR for the build"
	exit 1
fi

setopts && cdroot

if [[ 0 -ne $? ]]; then
	exit $?
fi

CURRENT_HASH=$(git log -1 --pretty='%H')

mkdir -p "$HOME/.liferay/builds"

time redeploy $1