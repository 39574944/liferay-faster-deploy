#!/bin/bash

TIMESTAMP=$(date +%Y%m%d)

pushd $(dirname "${BASH_SOURCE[0]}") > /dev/null
SCRIPT_FOLDER=$(pwd -P)
popd > /dev/null

branch() {
	# If we've already built the branch today, no need to rebuild it

	if [ -f "/var/www/html/builds/branches/${1}-${TIMESTAMP}.tar.gz" ]; then
		return 0
	fi

	# We flag whether or not we want to build a branch by making a folder,
	# so if that folder does not exist, don't bother

	if [ ! -d "$BUILD_FOLDER_PREFIX/$1" ]; then
		return 0
	fi

	# Determine the actual base branch to use for building

	if [ "master" == "$1" ]; then
		BASE_BRANCH=$1
	elif [ "$1" != "70x" ]; then
		BASE_BRANCH=ee-$(echo $1 | sed 's/\([0-9]\)/\1./g')
	else
		BASE_BRANCH=$(echo $1 | sed 's/\([0-9]\)/\1./g')
	fi

	# Check to see if we can successfully checkout the branch

	checkout $BASE_BRANCH

	if [ "$BASE_BRANCH" != "$(git branch | grep -F '*' | cut -d' ' -f 2)" ]; then
		return 1
	fi

	# Rebase against the old branch

	local upstream_remote=$(git for-each-ref --format='%(refname)' refs/remotes/ | grep "/upstream[^/]*/${BASE_BRANCH}$" | cut -d'/' -f 3)

	git rebase ${upstream_remote}/$BASE_BRANCH

	if [[ 0 -ne $? ]]; then
		git rebase --abort
		return 1
	fi

	# If we have an equivalent private branch, we should actually be building that

	local BUILT_PRIVATE=

	if [ "master" != "$1" ] && [ "" != "$(git for-each-ref --format='%(refname)' "refs/heads/${BASE_BRANCH}-private")" ]; then
		BUILT_PRIVATE=true

		checkout ${BASE_BRANCH}-private
		git rebase ${upstream_remote}/$BASE_BRANCH-private
		setportalcommit
	fi

	# Execute the build

	BUILD_FOLDER_PREFIX="$BUILD_FOLDER_PREFIX" \
		BUILD_FOLDER_SUFFIX="$TIMESTAMP" \
		ARCHIVE_FOLDER="/var/www/html/builds/branches" \
		TIMESTAMP="$TIMESTAMP" \
			$SCRIPT_FOLDER/prepare $@

	# If we have an equivalent private branch, also copy our build there

	if [ "" != "$BUILT_PRIVATE" ] && [ -d /var/www/html/builds/branches/$1-${TIMESTAMP}.tar.gz ]; then
		cp /var/www/html/builds/branches/$1-${TIMESTAMP}.tar.gz /var/www/html/builds/branches/$1-private-${TIMESTAMP}.tar.gz

		echo "Git Hash:" > /var/www/html/builds/branches/$1-private-${TIMESTAMP}.log
		cat git-commit-portal >> /var/www/html/builds/branches/$1-private-${TIMESTAMP}.log
		tail -n +3 /var/www/html/builds/branches/$1-${TIMESTAMP}.log >> /var/www/html/builds/branches/$1-private-${TIMESTAMP}.log
	fi

	# Only retain last three builds

	BUILD_COUNT=$(ls -1 "$BUILD_FOLDER_PREFIX/$1/" | grep -vF '.log' | grep -c '^')

	if [[ $BUILD_COUNT -gt 3 ]]; then
		for BUILD_ID in $(ls -1 "$BUILD_FOLDER_PREFIX/$1/" | grep -vF '.log' | sort | head -$(expr $BUILD_COUNT '-' 3)); do
			rm -rf "$BUILD_FOLDER_PREFIX/$1/$BUILD_ID"
		done
	fi

	# Clean up old logs as well

	rm -f $BUILD_FOLDER_PREFIX/$1/*.log

	for branch in master 70x 62x 61x; do
		local ACTIVE_BUILD=

		for LOG_ID in $(ls -1 "/var/www/html/builds/branches/" | grep -F $branch | grep -F '.log' | sort); do
			BUILD_ARCHIVE=$(echo "$LOG_ID" | sed 's/\.log//g').tar.gz

			if [ -f "/var/www/html/builds/branches/$BUILD_ARCHIVE" ]; then
				ACTIVE_BUILD=$BUILD_ARCHIVE
			elif [ "" == "$ACTIVE_BUILD" ]; then
				rm -f /var/www/html/builds/branches/$LOG_ID
			fi
		done
	done
}

branches() {
	if [ ! -d /var/www/html/builds/branches ]; then
		echo "No archive folder for branches, skipping"
		return 0
	fi

	# Clear out the data folder for all past builds

	for folder in $REBUILD; do
		if [ -d $BUILD_FOLDER_PREFIX/$folder ]; then
			for BUILD_ID in $(ls -1 "$BUILD_FOLDER_PREFIX/$folder/" | grep -vF '.log'); do
				rm -rf "$BUILD_FOLDER_PREFIX/$folder/$BUILD_ID/data"
			done
		fi
	done

	# Start build

	echo Started $(date)

	# Build all branches

	for folder in $REBUILD; do
		if [ "master" == "$folder" ]; then
			branch master 60
		elif [ "70x" == "$folder" ]; then
			branch 70x 70
		elif [ "62x" == "$folder" ]; then
			branch 62x 62
		elif [ "61x" == "$folder" ]; then
			branch 61x 61
		fi
	done

	echo Completed $(date)
}

checkout() {
	local WORKTREE_FOLDER=

	if [ -d .git/worktrees ]; then
		WORKTREE_FOLDER=$PWD/.git/worktrees
	elif [ -f .git ]; then
		WORKTREE_FOLDER=$(dirname "$(cut -d' ' -f 2 .git)")
	fi

	if [ "" != "$WORKTREE_FOLDER" ]; then
		for worktree in $WORKTREE_FOLDER/*; do
			if [ "refs/heads/$1" == "$(cut -d' ' -f 2 "${worktree}/HEAD")" ]; then
				cd "$(dirname "$(cat "${worktree}/gitdir")")"
			fi
		done
	fi

	git clean -xdf
	git reset --hard
	git checkout $1
}

fixpack() {
	# If we've already built the fixpack, no need to rebuild it

	if [ -f "/var/www/html/builds/fixpacks/${1}.tar.gz" ]; then
		return 0
	fi

	# If we have not checked out the tag locally, make sure to check it out

	if [ "" == "$(git tag | grep -F "$1")" ]; then
		if [[ $1 == fix-pack-* ]]; then
			git fetch --no-tags git@github.com:liferay/liferay-portal-ee.git tags/$1:refs/tags/$1
		else
			git fetch --no-tags git@github.com:liferay/liferay-portal.git tags/$1:refs/tags/$1
		fi

		if [ "" == "$(git tag | grep -F "$1")" ]; then
			return 1
		fi
	fi

	# If we have an equivalent private tag, we should actually be building that,
	# but because we have that logic, avoid building the private tag

	if [[ $1 == *-private ]]; then
		return 0
	fi

	local BUILT_PRIVATE=

	if [ "" != "$(git for-each-ref --format='%(refname)' "refs/tags/${1}-private")" ]; then
		BUILT_PRIVATE=true
		checkout ${1}-private
		setportalcommit
	else
		checkout $1
	fi

	# Execute the build

	BUILD_FOLDER_PREFIX="$BUILD_FOLDER_PREFIX/temp" \
		BUILD_FOLDER_SUFFIX="" \
		ARCHIVE_FOLDER="/var/www/html/builds/fixpacks" \
		TIMESTAMP="" \
			$SCRIPT_FOLDER/prepare $1 80

	# If we have an equivalent private tag, also copy our build there

	if [ "" != "$BUILT_PRIVATE" ] && [ -d /var/www/html/builds/fixpacks/$1.tar.gz ]; then
		cp /var/www/html/builds/fixpacks/$1.tar.gz /var/www/html/builds/fixpacks/$1-private.tar.gz

		echo "Git Hash:" > /var/www/html/builds/fixpacks/$1-private.log
		cat git-commit-portal >> /var/www/html/builds/fixpacks/$1-private.log
		tail -n +3 /var/www/html/builds/fixpacks/$1.log >> /var/www/html/builds/fixpacks/$1-private.log
	fi

	# Remove the temp folder where we were building to

	rm -rf "$BUILD_FOLDER_PREFIX/temp/$1"
}

fixpacks() {
	if [ ! -d /var/www/html/builds/fixpacks ]; then
		echo "No archive folder for fixpacks, skipping"
		return 0
	fi

	git ls-remote -t git@github.com:liferay/liferay-portal.git | \
		awk '{ print $2 }' | grep ga | grep -vF sync | \
		sort | cut -d'/' -f 3 > /var/www/html/builds/fixpacks/tags-ce.txt

	for tag_id in $(cat /var/www/html/builds/fixpacks/tags-ce.txt); do
		fixpack $tag_id
	done

	git ls-remote -t git@github.com:liferay/liferay-portal-ee.git | \
		awk '{ print $2 }' | grep 'fix-pack-\(base-61\|base-62\|base-70\|de-\)' | grep -v '\(test\|demo\)' | \
		sort -t'-' -nk4,5 | cut -d'/' -f 3 > /var/www/html/builds/fixpacks/tags.txt

	for tag_id in $(cat /var/www/html/builds/fixpacks/tags.txt); do
		fixpack $tag_id
	done
}

setportalcommit() {
	echo -e "\n\nUpdating git-commit-portal commit"

	echo git log -1 --pretty='%H' $(echo $1 | sed 's/-private$//g')
	git log -1 --pretty='%H' $(echo $1 | sed 's/-private$//g') | tee git-commit-portal

	ant -f build-working-dir.xml
}

update() {
	$SCRIPT_FOLDER/../github/fixupstream

	if [ "" == "$(git remote | grep '^upstream$')" ]; then
		git fetch origin --no-tags
	else
		for remote in $(git remote | grep '^upstream'); do
			git fetch $remote --no-tags
		done
	fi

	git reflog expire --expire=now --all
	git gc --prune
	return 0
}

if [ -z "${PORTAL_SOURCE_ROOT}" ]; then
	echo "Please set a PORTAL_SOURCE_ROOT for the build"
	exit 1
fi

if [ ! -e "$PORTAL_SOURCE_ROOT/.git" ]; then
	echo "${PORTAL_SOURCE_ROOT} is not a git repository"
	exit 1
fi

if [ -z "${BUILD_FOLDER_PREFIX}" ]; then
	echo "Please set a BUILD_FOLDER_PREFIX for the build"
	exit 1
fi

REBUILD="$@"

if [ "" == "$REBUILD" ]; then
	REBUILD="master 70x 62x 61x"
fi

if [ ! -e $(dirname $PORTAL_SOURCE_ROOT)/liferay-binaries-cache-2017 ]; then
	pushd $(dirname $PORTAL_SOURCE_ROOT)
	git clone git@github.com:liferay/liferay-binaries-cache-2017.git
fi

cd $(dirname $PORTAL_SOURCE_ROOT)/liferay-binaries-cache-2017
update
git rebase origin/master

cd $PORTAL_SOURCE_ROOT
update $REBUILD
branches $REBUILD
fixpacks