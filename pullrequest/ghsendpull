#!/bin/bash

addreviewer() {
	findreviewer $@

	if [[ 0 -ne $? ]]; then
		return 1
	fi

	reviewer_alias=$(echo "$1" | sed 's/[^a-zA-Z]//g')

	for remote in $(git remote | grep upstream); do
		local remote_url=$(git remote get-url $remote)

		# Don't do anything if we already created the remote, since
		# we can assume it's setup the way the user wants

		local new_remote_url=$(echo $remote_url | sed "s@:[^/]*/@:${reviewer}/@g")
		local new_remote=$(git remote -v | grep "${new_remote_url}" | awk '{ print $1 }' | sort -u)

		if [ "" != "$new_remote" ]; then
			continue
		fi

		# Add the new remote.

		new_remote=$(echo $remote | sed "s/upstream/${reviewer_alias}/g")

		echo "Adding remote $new_remote for $new_remote_url"
		git remote add $new_remote $new_remote_url

		# Set the proper tracking branches.

		tracked_branches=$(git remote show $remote | grep ' tracked$' | awk '{ print $1 }' | tr '\n' ' ')

		if [ "" != "$tracked_branches" ]; then
			git remote set-branches $new_remote $tracked_branches
		fi

		git fetch $new_remote --no-tags --prune
	done
}

findreviewer() {
	# Make sure that the remote does not already exist

	local remote_name=$(git remote | grep "^$1$")

	if [ "" != "$remote_name" ]; then
		reviewer=$(git remote get-url $remote_name | cut -d':' -f 2 | cut -d'/' -f 1)
		return 0
	fi

	# Search for the reviewer candidates based on the search string

	remote_name=$1
	local search_key=

	if [ "" == "$2" ]; then
		search_key=$1
	else
		search_key=$2
	fi

	reviewer=$($(dirname "${BASH_SOURCE[0]}")/gituser "$search_key" | cut -d'=' -f 1)

	# Make sure it's relatively unique. Namely, if there is already
	# a remote for the ambiguous matches, we'll accept that.

	for remote in $(git remote); do
		remote_user=$(git remote get-url $remote | cut -d':' -f 2 | cut -d'/' -f 1)

		if [ "" != "$(echo "$reviewer" | grep "^${remote_user}$")" ]; then
			echo "Skipping user ${remote_user} as they are under remote ${remote}"
			reviewer=$(echo "$reviewer" | grep -v "^${remote_user}$")

			if [ "" == "$reviewer" ]; then
				break
			fi
		elif [ "$remote_user" == "$search_key" ]; then
			reviewer=$remote_user
		fi
	done

	# Make sure we have a valid condition

	if [ "" == "$reviewer" ]; then
		echo "Unable to find reviewer $search_key"
		return 1
	fi

	if [[ 1 -ne $(echo "$reviewer" | wc -l) ]]; then
		echo -e "$search_key is ambiguous\n\n$reviewer"
		return 1
	fi
}

gitchanges() {
	. $(dirname "${BASH_SOURCE[0]}")/../gitchanges $@
}

reformat() {
	for folder in $(cat .redeploy/changes_gradle_1.txt .redeploy/changes_gradle_2.txt); do
		cd $folder
		pwd

		$(dirname "${BASH_SOURCE[0]}")/formatsource $BASE_BRANCH
		EXIT_CODE=$?

		cd -

		if [[ 0 -ne $EXIT_CODE ]]; then
			return $EXIT_CODE
		fi
	done

	if [[ 0 -ne $(wc -l .redeploy/changes_ant.txt | cut -d' ' -f 1) ]]; then
		cd portal-impl
		pwd

		$(dirname "${BASH_SOURCE[0]}")/formatsource $BASE_BRANCH
		EXIT_CODE=$?
		cd -

		if [[ 0 -ne $EXIT_CODE ]]; then
			return $EXIT_CODE
		fi
	fi
}

repmd() {
	if [ ! -d "tools/sdk" ]; then
		echo "Missing plugins SDK for PMD tool"
		ant setup-sdk
	fi

	CHANGES="$(grep -F '.java' .redeploy/changes.txt)"

	CHANGE_COUNT=0

	if [ "" != "$CHANGES" ]; then
		ant -Dpmd.output.type=text -Dpmd.java.includes="$(echo -n "$CHANGES" | tr '\n' ',')" run-pmd
		CHANGE_COUNT=$(wc -c pmd-reports/pmd-report.text | cut -d' ' -f 1)
	fi

	if [[ 0 -eq $CHANGE_COUNT ]]; then
		echo No violations detected.
		return 0
	fi

	cat pmd-reports/pmd-report.text
	return 1
}

sendpull() {
	GIT_ROOT=$PWD

	while [ ! -e "$GIT_ROOT/.git" ] && [ "/" != "$GIT_ROOT" ]; do
		GIT_ROOT=$(dirname $GIT_ROOT)
	done

	if [ ! -e "$GIT_ROOT/.git" ]; then
		echo "Unable to find version control root"
		return 1
	fi

	if [ "" == "$1" ]; then
		echo Please specify a reviewer
		return 1
	fi

	# Figure out where we are pushing our branch

	if [ -f "$GIT_ROOT/release.properties" ]; then
		. $(dirname "${BASH_SOURCE[0]}")/../getparent
	else
		CURRENT_BRANCH=$(git symbolic-ref --short HEAD)
		BASE_BRANCH=master
	fi

	remote_name=$(git branch -av | awk '{ print $1 }' | grep "remotes/origin[^/]*/${BASE_BRANCH}$" | cut -d'/' -f 2)

	if [ "" == "$remote_name" ]; then
		echo "Unable to identify origin for $BASE_BRANCH"
		return 1
	fi

	if [ "" == "$BASE_BRANCH" ]; then
		echo Unable to identify base branch
		return 1
	fi

	if [ "master" == "$CURRENT_BRANCH" ]; then
		echo Attempted to submit pull request from master
		return 1
	fi

	# Figure out who we are sending things for review

	addreviewer $@

	if [[ 0 -ne $? ]]; then
		return 1
	fi

	# Rebase against the upstream variant of the branch

	upstream_remote=$(git branch -av | awk '{ print $1 }' | grep "remotes/upstream[^/]*/${BASE_BRANCH}$" | cut -d'/' -f 2)

	if [ "" == "$upstream_remote" ]; then
		echo "Unable to identify upstream equivalent of $BASE_BRANCH"
		return 1
	fi

	git fetch --no-tags ${upstream_remote}
	git rebase ${upstream_remote}/${BASE_BRANCH}

	if [[ 0 -ne $? ]]; then
		return 1
	fi

	if [ -f "$GIT_ROOT/release.properties" ]; then
		pushd $GIT_ROOT > /dev/null

		gitchanges ${upstream_remote}/$BASE_BRANCH && reformat && repmd
		EXIT_CODE=$?

		popd > /dev/null

		if [[ 0 -ne $EXIT_CODE ]]; then
			return 1
		fi
	fi

	# Update our origin

	git push $remote_name $CURRENT_BRANCH

	if [[ 0 -ne $? ]]; then
		return 1
	fi

	# Open a web browser so we can submit the pull request

	current_user=$(git remote -v | grep origin | cut -d':' -f 2 | cut -d'/' -f 1 | sort -u)
	reviewer_remote=$(git branch -av | awk '{ print $1 }' | grep "remotes/${reviewer_alias}[^/]*/${BASE_BRANCH}$" | cut -d'/' -f 2)
	reviewer_repository=$(git remote get-url $reviewer_remote | cut -d'/' -f 2 | sed 's/\.git$//g' | uniq)

	python -m webbrowser "https://github.com/${reviewer}/${reviewer_repository}/compare/${BASE_BRANCH}...${current_user}:${CURRENT_BRANCH}"
}

setopts() {
	. $(dirname "${BASH_SOURCE[0]}")/../setopts
}

setopts

if [[ 0 -ne $? ]]; then
	exit 1
fi

sendpull $@